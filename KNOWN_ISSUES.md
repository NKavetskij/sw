# **Известные недостатки и сомнения по решению**
1. TypeRegistry с unordered_map и shared_ptr

Текущая реализация TypeRegistry для хранения характеристик использует unordered_map с shared_ptr, что при большом количестве юнитов и характеристик может приводить к фрагментации памяти. Каждая характеристика размещается в отдельной области памяти, что вызывает частые промахи кэша процессора при обращении к разным характеристикам юнита. Это особенно критично при большом количестве юнитов. Решением может быть хранение всех характеристик в непрерывных структурах, можно использовать Entity Component System подход.

2. Проблемы архитектуры. 

2.1. Каждый юнит реализует свой метод act(), что будет приводить к дублированию кода при добавлении новых юнитов со схожим поведением. Можно ввести систему поведений где каждое поведение представляет собой отдельный компонент, которые можно было бы комбинировать для создания различных типов юнитов.

2.2. Класс Unit следовало бы разделить на отдельные классы со своей ответственностью: для хранения и доступа к характеристикам, логики действий, управления состояниями, взаимодействия с игровым миром.

2.3. Можно также убрать жёсткую связь между контекстом (доступ к игровому миру) и поведением юнитов, например, с помощью введения публикации событий, которые производит юнит (движение, атака, ...).

3. Core и Features стоит разделить на отдельные библиотеки со своими CMakeLists.txt. 

4. Поиск пути. Текущий алгоритм движения использует простейший подход: движение по одной координате за раз. Если целевая клетка заблокирована другим юнитом, то юнит не пытается обойти препятствие, а атакует юнита из соседней клетки. Возможно, стоило бы реализовать полноценный алгоритм поиска пути при выполнении команды MARCH.

5. В классе World в std::unordered_map<Position, Unit*> _unitPositions следует перейти на использование weak_ptr для Unit. Сейчас есть риск висячих указателей при удалении юнитов.
